"""
Module for postprocessing of the files generated by the eval.py script.

Run:
    python postpro.py --src <src> --dst <dst> --set <set> --threshold <threshold> --connec <connec> --min-vol <min-vol>
"""

import argparse
import glob
import os
import re

import numpy as np
import cc3d
import pandas as pd
import nibabel as nib
from tqdm import tqdm    

def postprocessing(src: str, dst: str, set: str, threshold: float, connec: int = 6, min_vol: int = -1):
    """
    Postprocessing of the files generated by the eval.py script.

    Parameters
    ----------
    src (str): Path to the folder containing the files generated by the eval.py script.
    dst (str): Path to the folder where the postprocessed files will be saved.
    set (str): Name of the data set. Accepted values: "val", "test".
    threshold (float): Threshold to apply to the predicted masks.
    connec (int, optional): Connectivity for connected components. Defaults to 6. Accepted values: 6, 18, 26.
    min_vol (int, optional): Minimum volume of the connected components to keep. Defaults to -1.

    Notes
    -----
    The src folder should contain files with the format "RibFrac<scan-number>-pred_mask.npy".
    The dst folder should be empty.
    The dst folder will contain the postprocessed files with the format "RibFrac<scan-number>.nii.gz".
    Additionally, "ribfrac-<set>-pred.csv" will be generated in the dst folder.

    Example:
        src/
        ├── RibFrac400-pred_mask.npy
        ├── RibFrac401-pred_mask.npy
        ├── ...
        └── RibFrac500-pred_mask.npy
        dst/
        ├── ribfrac-val-pred.csv
        ├── RibFrac400.nii.gz
        ├── RibFrac401.nii.gz
        ├── ...
        └── RibFrac500.nii.gz

    This function does the following:
        1. Threshold the predicted masks to obtain binary masks.
        2. Compute connected components on the binary masks.
        3. Remove small connected components. (optional)
        4. Compute the confidence of each connected component with average of the predicted probabilities of the voxels in the original predicted mask.
        5. Save the connected components as "RibFrac<scan-number>.nii.gz".
        6. Generate "ribfrac-<set>-pred.csv".

    Following the format from https://github.com/M3DV/RibFrac-Challenge#evaluation, the output files will contain the following information:
        - "RibFrac<scan-number>.nii.gz": scan of the same size as the input array ("RibFrac<scan-number>.npy") containing the labels (label_id) of the connected components.
        - "ribfrac-<set>-pred.csv": csv file with the following columns:
            - "public_id": scan number, e.g. "RibFrac400".
            - "label_id": integer label of the connected component, corresponding to the label in the "RibFrac<scan-number>.nii.gz" file.
            - "confidence": confidence of the prediction.
            - "label_code": integer label code of the connected component. 0 for the negative class and 1 for the positive class, since this is a detection (binary classification) problem.

    """

    assert set in ["val", "test"], "Invalid set. Accepted values: 'val', 'test'."
    assert connec in [6, 18, 26], "Invalid connectivity. Accepted values: 6, 18, 26."

    # src
    filelist = glob.glob(os.path.join(src, "RibFrac*-pred_mask.npy"))
    filelist.sort()

    # dst
    os.makedirs(dst, exist_ok=True)
    data = []

    for filepath in tqdm(filelist, desc="Postprocessing"):

        # 0. Load
        filename = os.path.basename(filepath)
        public_id = re.search(r"(RibFrac(\d+))-pred_mask.npy", filename).group(1)

        pred_mask = np.load(filepath)  # (z, x, y)
        pred_mask = np.transpose(pred_mask, (1, 2, 0))  # (x, y, z)

        # 1. Thresholding
        pred_mask_bin = pred_mask >= threshold
        pred_mask_bin = pred_mask_bin.astype(np.uint8)

        # TODO: closing

        # 2. Connected components
        labels_out = cc3d.connected_components(pred_mask_bin, connectivity=connec)  # includes 0 (background)

        unique, counts = np.unique(labels_out, return_counts=True)
        volumes = dict(zip(unique, counts))

        cc = np.zeros_like(labels_out)

        # background
        confidence = 1 - np.mean(pred_mask[labels_out == 0])
        data.append([public_id, 0, confidence, 0])

        n = 0
        for label, image in cc3d.each(labels_out, binary=True, in_place=True):
            # 'each' does no include background (0)

            # 3. Remove small cc
            if volumes[label] >= min_vol:
                n += 1
                cc[image] = n
            
                # 4. Confidence
                confidence = np.mean(pred_mask[image])

                data.append([public_id, n, confidence, 1])

        n += 1  # background
        
        # 5. Save
        labels_out = labels_out.astype(np.uint8)
        labels_out = nib.Nifti1Image(labels_out, np.eye(4))
        nib.save(labels_out, os.path.join(dst, f"{public_id}.nii.gz"))

    # 6. Generate csv
    df = pd.DataFrame(
        data=data,
        columns=["public_id", "label_id", "confidence", "label_code"],
    )
    df.to_csv(os.path.join(dst, f"ribfrac-{set}-pred.csv"), index=False)


if __name__ == "__main__":

    # parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--src",
        type=str,
        default="./data/",
        help="Path to the folder containing the files generated by the eval.py script.",
    )
    parser.add_argument(
        "--dst",
        type=str,
        default="./data/",
        help="Path to the folder where the postprocessed files will be saved.",
    )
    parser.add_argument(
        "--set",
        type=str,
        choices=["val", "test"],
        help="Name of the data set. Accepted values: 'val', 'test'.",
    )
    parser.add_argument(
        "--threshold",
        type=float,
        default=0.5,
        help="Threshold to apply to the predicted masks.",
    )
    parser.add_argument(
        "--connec",
        type=int,
        choices=[6, 18, 26],
        default=6,
        help="Connectivity for connected components. Accepted values: 6, 18, 26.",
    )
    parser.add_argument(
        "--min-vol",
        type=int,
        default=-1,
        help="Minimum volume of the connected components to keep.",
    )
    args = parser.parse_args()

    postprocessing(args.src, args.dst, args.set, args.threshold, args.connec, args.min_vol)
